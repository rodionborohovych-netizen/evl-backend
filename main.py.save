"""EVL Production Backend"""
from fastapi import FastAPI, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Dict, Optional
import httpx
import asyncio
import time
from datetime import datetime
from math import radians, sin, cos, sqrt, atan2

app = FastAPI(title="EVL Analyzer API", version="1.0.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

OPEN_CHARGE_MAP_KEY = "553131e9-33b0-49ee-834b-416fc9d4202a"
last_nominatim_call = 0

class Location(BaseModel):
    latitude: float
    longitude: float
    address: str
    city: str
    country: str
    postal_code: Optional[str] = None

class Charger(BaseModel):
    id: str
    name: str
    network: str
    latitude: float
    longitude: float
    distance_km: float
    connectors: int
    power_kw: float
    connector_types: List[str]
    pricing: Optional[str] = None
    operator: Optional[str] = None
    access_type: str
    status: str

class POIData(BaseModel):
    supermarkets: int
    shopping_centers: int
    office_buildings: int
    hotels: int
    restaurants: int
    parking_facilities: int
    total_count: int

class Demographics(BaseModel):
    population_density: float
    median_income: float
    employment_rate: float
    ev_adoption_rate: float
    projected_growth_rate: float
    area_type: str

class TrafficData(BaseModel):
    daily_volume: int
    peak_congestion_index: float
    average_speed_kmh: float
    road_type: str
    commuter_flow: str

async def rate_limit_nominatim():
    global last_nominatim_call
    now = time.time()
    if now - last_nominatim_call < 1:
        await asyncio.sleep(1 - (now - last_nominatim_call))
    last_nominatim_call = time.time()

def calculate_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:
    R = 6371
    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
    c = 2 * atan2(sqrt(a), sqrt(1-a))
    return R * c

async def geocode_nominatim(address: str) -> Optional[Location]:
    await rate_limit_nominatim()
    url = "https://nominatim.openstreetmap.org/search"
    headers = {"User-Agent": "EVL-Analyzer/1.0"}
    params = {"q": address, "format": "json", "limit": 1, "addressdetails": 1}
    
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(url, params=params, headers=headers, timeout=10.0)
            data = response.json()
            if data:
                result = data[0]
                addr = result.get("address", {})
                return Location(
                    latitude=float(result["lat"]),
                    longitude=float(result["lon"]),
                    address=result["display_name"],
                    city=addr.get("city", addr.get("town", addr.get("village", ""))),
                    country=addr.get("country", ""),
                    postal_code=addr.get("postcode")
                )
    except Exception as e:
        print(f"Geocoding error: {e}")
    return None

async def get_chargers(lat: float, lng: float, radius_km: int) -> List[Charger]:
    url = "https://api.openchargemap.io/v3/poi/"
    params = {
        "output": "json", "latitude": lat, "longitude": lng,
        "distance": radius_km, "distanceunit": "km",
        "maxresults": 100, "compact": "false",
        "key": OPEN_CHARGE_MAP_KEY
    }
    
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(url, params=params, timeout=15.0)
            data = response.json()
            chargers = []
            
            for poi in data:
                if not poi.get("AddressInfo"):
                    continue
                
                addr = poi["AddressInfo"]
                connections = poi.get("Connections", [])
                max_power = 0
                total_connectors = 0
                connector_types = []
                
                for conn in connections:
                    power = conn.get("PowerKW", 0)
                    if power and power > max_power:
                        max_power = power
                    total_connectors += conn.get("Quantity", 1)
                    conn_type = conn.get("ConnectionType", {}).get("Title", "Unknown")
                    if conn_type and conn_type not in connector_types:
                        connector_types.append(conn_type)
                
                distance = calculate_distance(lat, lng, addr["Latitude"], addr["Longitude"])
                
                chargers.append(Charger(
                    id=f"ocm_{poi['ID']}",
                    name=addr.get("Title", "Unknown"),
                    network="Open Charge Map",
                    latitude=addr["Latitude"],
                    longitude=addr["Longitude"],
                    distance_km=round(distance, 2),
                    connectors=total_connectors,
                    power_kw=max_power,
                    connector_types=connector_types,
                    operator=poi.get("OperatorInfo", {}).get("Title") if poi.get("OperatorInfo") else None,
                    access_type=poi.get("UsageType", {}).get("Title", "Public") if poi.get("UsageType") else "Public",
                    status="operational" if poi.get("StatusType", {}).get("IsOperational") else "out_of_service"
                ))
            
            chargers.sort(key=lambda x: x.distance_km)
            return chargers
    except Exception as e:
        print(f"Chargers error: {e}")
        return []

async def get_pois(lat: float, lng: float, radius_m: int) -> POIData:
    overpass_url = "https://overpass-api.de/api/interpreter"
    query = f"""
    [out:json][timeout:25];
    (
      node["shop"="supermarket"](around:{radius_m},{lat},{lng});
      node["shop"="mall"](around:{radius_m},{lat},{lng});
      node["amenity"="restaurant"](around:{radius_m},{lat},{lng});
      node["tourism"="hotel"](around:{radius_m},{lat},{lng});
      node["amenity"="parking"](around:{radius_m},{lat},{lng});
      node["office"](around:{radius_m},{lat},{lng});
    );
    out body;
    """
    
    try:
        async with httpx.AsyncClient() as client:
            response = await client.post(overpass_url, data={"data": query}, timeout=30.0)
            elements = response.json().get("elements", [])
            
            supermarkets = sum(1 for e in elements if e.get("tags", {}).get("shop") == "supermarket")
            malls = sum(1 for e in elements if e.get("tags", {}).get("shop") == "mall")
            restaurants = sum(1 for e in elements if e.get("tags", {}).get("amenity") == "restaurant")
            hotels = sum(1 for e in elements if e.get("tags", {}).get("tourism") == "hotel")
            parking = sum(1 for e in elements if e.get("tags", {}).get("amenity") == "parking")
            offices = sum(1 for e in elements if "office" in e.get("tags", {}))
            
            return POIData(
                supermarkets=supermarkets, shopping_centers=malls,
                office_buildings=offices, hotels=hotels,
                restaurants=restaurants, parking_facilities=parking,
                total_count=len(elements)
            )
    except Exception as e:
        print(f"POI error: {e}")
        return POIData(supermarkets=0, shopping_centers=0, office_buildings=0,
                      hotels=0, restaurants=0, parking_facilities=0, total_count=0)

@app.get("/")
async def root():
    return {
        "service": "EVL Analyzer API",
        "version": "1.0.0",
        "status": "operational",
        "endpoints": ["/api/geocode", "/api/chargers", "/api/analyze", "/health"]
    }

@app.get("/health")
async def health():
    return {"status": "healthy", "timestamp": datetime.utcnow().isoformat()}

@app.get("/api/geocode")
async def geocode(address: str = Query(...)):
    location = await geocode_nominatim(address)
    if not location:
        raise HTTPException(status_code=404, detail="Location not found")
    return location

@app.get("/api/chargers")
async def get_chargers_endpoint(
    lat: float = Query(...),
    lng: float = Query(...),
    radius: int = Query(5, ge=1, le=50)
):
    chargers = await get_chargers(lat, lng, radius)
    return {"count": len(chargers), "chargers": [c.dict() for c in chargers]}

@app.get("/api/analyze")
async def analyze(
    address: str = Query(...),
    radius: int = Query(5, ge=1, le=50)
):
    location = await geocode_nominatim(address)
    if not location:
        raise HTTPException(status_code=404, detail="Location not found")
    
    lat, lng = location.latitude, location.longitude
    chargers, pois = await asyncio.gather(
        get_chargers(lat, lng, radius),
        get_pois(lat, lng, radius * 1000)
    )
    
    demographics = Demographics(
        population_density=3200, median_income=42000,
        employment_rate=0.73, ev_adoption_rate=0.082,
        projected_growth_rate=0.21, area_type="Urban"
    )
    
    traffic = TrafficData(
        daily_volume=25000, peak_congestion_index=0.65,
        average_speed_kmh=48, road_type="A-Road",
        commuter_flow="High"
    )
    
    nearby = len([c for c in chargers if c.distance_km < 2])
    overall_score = max(0.3, min(0.9 - nearby * 0.1, 0.95))
    
    return {
        "location": location.dict(),
        "chargers": [c.dict() for c in chargers],
        "traffic": traffic.dict(),
        "demographics": demographics.dict(),
        "poi": pois.dict(),
        "scores": {
            "overall": round(overall_score, 2),
            "demand": 0.72,
            "traffic": 0.81,
            "poi": 0.68,
            "competition": min(nearby * 0.15, 0.5),
            "gap_opportunity": 0.42
        },
        "roi_projection": {
            "estimated_annual_revenue": int(50000 * overall_score),
            "install_cost_estimate": 80000,
            "payback_period_years": round(80000 / (50000 * overall_score), 1),
            "year_5_profit": int(50000 * overall_score * 5 - 80000)
        },
        "recommendations": [
            {"type": "success", "text": f"Location score: {int(overall_score * 100)}%"},
            {"type": "info", "text": f"Found {len(chargers)} existing chargers"}
        ]
    }
open -a TextEdit
code main.py
touch main.py
open main.py
curl -o main.py https://pastebin.com/raw/placeholder
cat > main.pytouch main.py
open -a TextEdit main.py
touch main.py
open -a TextEdit main.py
cat > main.py << 'EOF'
"""EVL Production Backend"""
from fastapi import FastAPI, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Dict, Optional
import httpx
import asyncio
import time
from datetime import datetime
from math import radians, sin, cos, sqrt, atan2

app = FastAPI(title="EVL Analyzer API", version="1.0.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

OPEN_CHARGE_MAP_KEY = "553131e9-33b0-49ee-834b-416fc9d4202a"
last_nominatim_call = 0

class Location(BaseModel):
    latitude: float
    longitude: float
    address: str
    city: str
    country: str
    postal_code: Optional[str] = None

class Charger(BaseModel):
    id: str
    name: str
    network: str
    latitude: float
    longitude: float
    distance_km: float
    connectors: int
    power_kw: float
    connector_types: List[str]
    pricing: Optional[str] = None
    operator: Optional[str] = None
    access_type: str
    status: str

class POIData(BaseModel):
    supermarkets: int
    shopping_centers: int
    office_buildings: int
    hotels: int
    restaurants: int
    parking_facilities: int
    total_count: int

class Demographics(BaseModel):
    population_density: float
    median_income: float
    employment_rate: float
    ev_adoption_rate: float
    projected_growth_rate: float
    area_type: str

class TrafficData(BaseModel):
    daily_volume: int
    peak_congestion_index: float
    average_speed_kmh: float
    road_type: str
    commuter_flow: str

async def rate_limit_nominatim():
    global last_nominatim_call
    now = time.time()
    if now - last_nominatim_call < 1:
        await asyncio.sleep(1 - (now - last_nominatim_call))
    last_nominatim_call = time.time()

def calculate_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:
    R = 6371
    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
    c = 2 * atan2(sqrt(a), sqrt(1-a))
    return R * c

async def geocode_nominatim(address: str) -> Optional[Location]:
    await rate_limit_nominatim()
    url = "https://nominatim.openstreetmap.org/search"
    headers = {"User-Agent": "EVL-Analyzer/1.0"}
    params = {"q": address, "format": "json", "limit": 1, "addressdetails": 1}
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(url, params=params, headers=headers, timeout=10.0)
            data = response.json()
            if data:
                result = data[0]
                addr = result.get("address", {})
                return Location(
                    latitude=float(result["lat"]),
                    longitude=float(result["lon"]),
                    address=result["display_name"],
                    city=addr.get("city", addr.get("town", addr.get("village", ""))),
                    country=addr.get("country", ""),
                    postal_code=addr.get("postcode")
                )
    except Exception as e:
        print(f"Geocoding error: {e}")
    return None

async def get_chargers(lat: float, lng: float, radius_km: int) -> List[Charger]:
    url = "https://api.openchargemap.io/v3/poi/"
    params = {"output": "json", "latitude": lat, "longitude": lng, "distance": radius_km, "distanceunit": "km", "maxresults": 100, "compact": "false", "key": OPEN_CHARGE_MAP_KEY}
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(url, params=params, timeout=15.0)
            data = response.json()
            chargers = []
            for poi in data:
                if not poi.get("AddressInfo"):
                    continue
                addr = poi["AddressInfo"]
                connections = poi.get("Connections", [])
                max_power = 0
                total_connectors = 0
                connector_types = []
                for conn in connections:
                    power = conn.get("PowerKW", 0)
                    if power and power > max_power:
                        max_power = power
                    total_connectors += conn.get("Quantity", 1)
                    conn_type = conn.get("ConnectionType", {}).get("Title", "Unknown")
                    if conn_type and conn_type not in connector_types:
                        connector_types.append(conn_type)
                distance = calculate_distance(lat, lng, addr["Latitude"], addr["Longitude"])
                chargers.append(Charger(
                    id=f"ocm_{poi['ID']}",
                    name=addr.get("Title", "Unknown"),
                    network="Open Charge Map",
                    latitude=addr["Latitude"],
                    longitude=addr["Longitude"],
                    distance_km=round(distance, 2),
                    connectors=total_connectors,
                    power_kw=max_power,
                    connector_types=connector_types,
                    operator=poi.get("OperatorInfo", {}).get("Title") if poi.get("OperatorInfo") else None,
                    access_type=poi.get("UsageType", {}).get("Title", "Public") if poi.get("UsageType") else "Public",
                    status="operational" if poi.get("StatusType", {}).get("IsOperational") else "out_of_service"
                ))
            chargers.sort(key=lambda x: x.distance_km)
            return chargers
    except Exception as e:
        print(f"Chargers error: {e}")
        return []

async def get_pois(lat: float, lng: float, radius_m: int) -> POIData:
    overpass_url = "https://overpass-api.de/api/interpreter"
    query = f"""[out:json][timeout:25];(node["shop"="supermarket"](around:{radius_m},{lat},{lng});node["shop"="mall"](around:{radius_m},{lat},{lng});node["amenity"="restaurant"](around:{radius_m},{lat},{lng});node["tourism"="hotel"](around:{radius_m},{lat},{lng});node["amenity"="parking"](around:{radius_m},{lat},{lng});node["office"](around:{radius_m},{lat},{lng}););out body;"""
    try:
        async with httpx.AsyncClient() as client:
            response = await client.post(overpass_url, data={"data": query}, timeout=30.0)
            elements = response.json().get("elements", [])
            return POIData(
                supermarkets=sum(1 for e in elements if e.get("tags", {}).get("shop") == "supermarket"),
                shopping_centers=sum(1 for e in elements if e.get("tags", {}).get("shop") == "mall"),
                office_buildings=sum(1 for e in elements if "office" in e.get("tags", {})),
                hotels=sum(1 for e in elements if e.get("tags", {}).get("tourism") == "hotel"),
                restaurants=sum(1 for e in elements if e.get("tags", {}).get("amenity") == "restaurant"),
                parking_facilities=sum(1 for e in elements if e.get("tags", {}).get("amenity") == "parking"),
                total_count=len(elements)
            )
    except Exception as e:
        return POIData(supermarkets=0, shopping_centers=0, office_buildings=0, hotels=0, restaurants=0, parking_facilities=0, total_count=0)

@app.get("/")
async def root():
    return {"service": "EVL Analyzer API", "version": "1.0.0", "status": "operational"}

@app.get("/health")
async def health():
    return {"status": "healthy", "timestamp": datetime.utcnow().isoformat()}

@app.get("/api/analyze")
async def analyze(address: str = Query(...), radius: int = Query(5, ge=1, le=50)):
    location = await geocode_nominatim(address)
    if not location:
        raise HTTPException(status_code=404, detail="Location not found")
    lat, lng = location.latitude, location.longitude
    chargers, pois = await asyncio.gather(get_chargers(lat, lng, radius), get_pois(lat, lng, radius * 1000))
    demographics = Demographics(population_density=3200, median_income=42000, employment_rate=0.73, ev_adoption_rate=0.082, projected_growth_rate=0.21, area_type="Urban")
    traffic = TrafficData(daily_volume=25000, peak_congestion_index=0.65, average_speed_kmh=48, road_type="A-Road", commuter_flow="High")
    nearby = len([c for c in chargers if c.distance_km < 2])
    overall_score = max(0.3, min(0.9 - nearby * 0.1, 0.95))
    return {"location": location.dict(), "chargers": [c.dict() for c in chargers], "traffic": traffic.dict(), "demographics": demographics.dict(), "poi": pois.dict(), "scores": {"overall": round(overall_score, 2), "demand": 0.72, "traffic": 0.81, "poi": 0.68, "competition": min(nearby * 0.15, 0.5), "gap_opportunity": 0.42}, "roi_projection": {"estimated_annual_revenue": int(50000 * overall_score), "install_cost_estimate": 80000, "payback_period_years": round(80000 / (50000 * overall_score), 1), "year_5_profit": int(50000 * overall_score * 5 - 80000)}, "recommendations": [{"type": "success", "text": f"Location score: {int(overall_score * 100)}%"}, {"type": "info", "text": f"Found {len(chargers)} existing chargers"}]}
EOF
uvicorn main:app --reload
python3 << 'ENDOFFILE'
code = """from fastapi import FastAPI, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional
import httpx, asyncio, time
from datetime import datetime
from math import radians, sin, cos, sqrt, atan2

app = FastAPI(title="EVL API")
app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_credentials=True, allow_methods=["*"], allow_headers=["*"])
OPEN_CHARGE_MAP_KEY = "553131e9-33b0-49ee-834b-416fc9d4202a"
last_call = 0

class Location(BaseModel):
    latitude: float
    longitude: float
    address: str
    city: str
    country: str

class Charger(BaseModel):
    id: str
    name: str
    latitude: float
    longitude: float
    distance_km: float
    connectors: int
    power_kw: float

async def geocode(address):
    global last_call
    await asyncio.sleep(max(0, 1 - (time.time() - last_call)))
    last_call = time.time()
    async with httpx.AsyncClient() as c:
        r = await c.get("https://nominatim.openstreetmap.org/search", params={"q": address, "format": "json", "limit": 1}, headers={"User-Agent": "EVL/1.0"}, timeout=10.0)
        d = r.json()
        if d: return Location(latitude=float(d[0]["lat"]), longitude=float(d[0]["lon"]), address=d[0]["display_name"], city="", country="")

async def get_chargers(lat, lng, radius):
    async with httpx.AsyncClient() as c:
        r = await c.get("https://api.openchargemap.io/v3/poi/", params={"output": "json", "latitude": lat, "longitude": lng, "distance": radius, "maxresults": 50, "key": OPEN_CHARGE_MAP_KEY}, timeout=15.0)
        result = []
        for p in r.json():
            if not p.get("AddressInfo"): continue
            a = p["AddressInfo"]
            result.append(Charger(id=str(p["ID"]), name=a.get("Title", "Unknown"), latitude=a["Latitude"], longitude=a["Longitude"], distance_km=round(a.get("Distance", 0), 2), connectors=len(p.get("Connections", [])), power_kw=max([c.get("PowerKW", 0) for c in p.get("Connections", [])] or [0])))
        return result

@app.get("/")
async def root():
    return {"service": "EVL API", "status": "operational"}

@app.get("/health")
async def health():
    return {"status": "healthy"}

@app.get("/api/analyze")
async def analyze(address: str = Query(...), radius: int = Query(5)):
    loc = await geocode(address)
    if not loc: raise HTTPException(404, "Not found")
    chargers = await get_chargers(loc.latitude, loc.longitude, radius)
    score = max(0.3, min(0.9 - len([c for c in chargers if c.distance_km < 2]) * 0.1, 0.95))
    return {"location": loc.dict(), "chargers": [c.dict() for c in chargers], "scores": {"overall": round(score, 2)}, "roi_projection": {"estimated_annual_revenue": int(50000 * score)}, "recommendations": [{"text": f"Score: {int(score*100)}%"}, {"text": f"Found {len(chargers)} chargers"}]}
"""
with open('main.py', 'w') as f:
    f.write(code)
print('File created!')
ENDOFFILE

